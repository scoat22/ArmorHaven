// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#include "SimplexNoise.compute"

#define UI0 1597334673U
#define UI1 3812015801U
#define UI2 uint2(UI0, UI1)
#define UI3 uint3(UI0, UI1, 2798796415U)
#define UIF 1.0 / float(0xffffffffU)

static const int numThreads = 8;


// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;

uint resolution;
float worleyFreq;
int fbmOctaves;
float fbmLacunarity;
float fbmPersistence;
float fbmAmplitude;

// base noise settings
float baseFrequency;
float4 baseNoiseOffset;

float coverageFreq;
// first noise settings
float4 noiseOffset1;
// second noise settings
float4 noiseOffset2;
// third noise settings
float frequency3;
float4 noiseOffset3;
// ==============================================================================================
// utility functions

float2 hash33(float2 p) {
    uint2 q = uint2(int2(p)) * UI2;
    q = (q.x ^ q.y) * UI2;
    return -1. + 2. * float2(q) * UIF;
}

float remap(float value, float ol, float oh, float nl, float nh) {
  return nl + (value - ol) * (nh - nl) / (oh - ol);
}

float saturateNoise(float x){
    return -1/(pow(10,x - 0.12)) + 1.3;
}
// ==============================================================================================

float worleyNoise2D(float2 uv, float freq){
    float2 id = floor(uv);
    float2 p = frac(uv);

    float minDist = 10000.;
    for (float x = -1.; x <= 1.; ++x){
        for(float y = -1.; y <= 1.; ++y){
            float2 offset = float2((float)x, (float)y);
            float2 h = hash33(((id + offset) % float2(freq, freq))) * .5 + .5;
            h += offset;
            float2 d = p - h;
            minDist = min(minDist, dot(d, d));
            
        }
    }
    return 1 - minDist;
}

float worleyFbm(float2 uv, float freq) {
  float noise = worleyNoise2D(uv * freq, freq) * .625 +
                worleyNoise2D(uv * freq * 2., freq * 2.) * .25 +
                worleyNoise2D(uv * freq * 4., freq * 4.) * .125;
  return noise;
}

float fbm(float2 uv, float2 offset, float freq){
    // const int NUM_OCTAVES = 6;
    float G = exp2(-.85);
    uv = uv + offset;

    float value = 0.0;
    float amplitude = fbmAmplitude;
    float frequency = freq;
    for (int i = 0; i < fbmOctaves; ++i) {
        value += amplitude * snoise(uv * frequency);
        frequency *= fbmLacunarity;
        amplitude *= fbmPersistence;
    }
    return value;

}

[numthreads(numThreads,numThreads,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!
    float2 uv = (id / (float) resolution).xy;
    // float perlinFbm = lerp(1.0, fbm(uv * fbmScale), 0.5);

    // float2 randomOffset = float2(123, 12);
    float baseFbm = lerp(1.0, fbm(uv, baseNoiseOffset.xy, baseFrequency), 0.5);

    float perlinFbm =  lerp(1.0, fbm(uv, noiseOffset1.xy, coverageFreq), 0.5);
    perlinFbm *= baseFbm;
    perlinFbm = saturate(perlinFbm);

    float worley = worleyFbm(uv, worleyFreq);
    float perlinFbm2 = lerp(1.0, fbm(uv, noiseOffset2.xy, coverageFreq), 0.5);
    float perlinWorley = perlinFbm2 * remap( 1 - perlinFbm2 , 0., 1., worley , 1.);
    perlinWorley *= baseFbm;
    perlinWorley = saturate(perlinWorley);

    float perlinFbm3 = lerp(1.0, fbm(uv, noiseOffset3.xy, frequency3), 0.5);
    perlinFbm3 = saturate(perlinFbm3);

    Result[id.xy] = float4(perlinFbm, perlinWorley, 1.0, 1.0);
}
